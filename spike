#!/usr/bin/env ruby

raise 'requires ruby 1.9.2' unless RUBY_VERSION == '1.9.2'
%w(rubygems bundler/setup typhoeus digest/sha1 time).each { |lib| require(lib) }

#
# TODO:
#
# header validation, only allow correct headers, say which ones are required
# body validation
# list all methods, uri validation, so no incorrect methods can get through?
# each method knows how to parse the body content... return nokogiri doc?
# end goal: works on all aws services, requires you only to read their api
# docs to find what you need, but the library lists all the possible api calls
# and their requirements and constraints, allowing for auto generation of
# documentation and etc, i think... and auto generation of tests.
#

class Best3
  #API = [
  #  {:request_method => 'GET'},
  #  {:request_method => 'PUT'}
  #  {:request_method => 'HEAD'}
  #]

  def initialize(*args)
    @key, @secret = args
    self
  end

  def s3(bucket)
    @bucket = bucket
    self
  end

  def call(request_method, uri, headers = {}, body = nil)
    #match = API.find { |entry| entry[:request_method] == request_method }
    #if not match
    #  raise "No match in API for request method #{request_method.inspect}."
    #else
      _(request_method, uri, headers.clone, body)
    #end
  end

private

  def _(request_method, uri, headers, body = nil)
    if body
      content = body.read
      body.close
      body = content
    end
    #HTTParty.send(request_method.downcase, "http://#{@bucket}.s3.amazonaws.com#{uri}", :headers => make_headers(request_method, uri, headers, body), :body => body)
    Typhoeus::Request.send(request_method.downcase, "http://#{@bucket}.s3.amazonaws.com#{uri}", :headers => make_headers(request_method, uri, headers, body), :body => body)
  end

  def make_headers(request_method, uri, headers, body = nil)
    headers['Date'] = Time.now.rfc822
    headers['Authorization'] = make_auth(request_method, uri, headers, body)
    headers
  end

  def make_auth(request_method, uri, headers, body = nil)
    str = []
    str << request_method
    str << ''
    str << '' if not headers['Content-Type'] # get requests require an empty line instead of the content type
    headers.keys.sort { |a, b| a.downcase <=> b.downcase }.each do |key|
      if key.match(/^x-amz/i) # convert special amz headers to expected format
        str << "#{key.downcase}:#{headers[key]}"
      else
        str << headers[key] # other headers just send the value
      end
    end
    str << "/#{@bucket}#{uri}"
    str = str.join("\n").chomp
    # auth key thingo stolen from aws::s3 library, lol.
    "AWS #{@key}:#{[OpenSSL::HMAC.digest(OpenSSL::Digest::Digest.new('sha1'), @secret, str)].pack('m').strip}"
  end
end

def Best3(*args) # i miss _why.
  Best3.new(*args)
end

s3 = Best3('key', 'secret').s3('ryan-s3-testing')
#puts s3.inspect
(100..110).each do |n|
  puts s3.('PUT', "/dog#{n}.png", {'x-amz-acl' => 'public-read', 'x-amz-meta-fark' => 'omgwtf', 'Content-Type' => 'image/png'}, open('./dog.png')).code
end
puts s3.('HEAD', '/dog1.png').inspect # why are they in an array?
puts s3.('HEAD', '/dog1.png').headers_hash.inspect # why are they in an array?
#puts s3.('PUT', '/dog.png', {'x-amz-meta-rand' => (rand() * 1000).to_i.to_s, 'x-amz-acl' => 'public-read', 'x-amz-storage-class' => 'STANDARD', 'x-amz-metadata-directive' => 'REPLACE', 'x-amz-copy-source' => '/ryan-s3-testing/dog.png'}).inspect
#puts s3.('GET', '/').inspect
#puts s3.('GET', '/?versioning').inspect
#puts s3.('GET', '/?policy').inspect
#puts s3.('GET', '/?logging').inspect
#puts s3.('GET', '/?location').inspect
